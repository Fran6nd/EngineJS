class Scene{constructor(t,r,e=!1){InputManager.init(),this.id=0,this.layers=new Array(10),this.uiLayer=new Map,this.debug=e;for(var s=0;s<this.layers.length;s++)this.layers[s]=new Map;this.canvas=t,this.ctx=r,this.t1=(new Date).getTime(),this.t2=(new Date).getTime()}instantiate(t,r=0){t.id=this.id.toString(10),t.layer=r,this.layers[r].set(t.id,t),this.id++}draw(){this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);for(var t=0;t<this.layers.length;t++)for(const[r,e]of this.layers[t].entries())e.draw(this.canvas,this.ctx);for(const[t,r]of this.uiLayer.entries())r.draw(this.canvas,this.ctx);this.ctx.font="15px Arial",this.ctx.fillStyle="#000000",this.ctx.fillText("Score: "+(new Date).getTime().toString(10),0,20)}debugDraw(){for(var t=0;t<this.layers.length;t++)for(const[r,e]of this.layers[t].entries())e.debugDraw(this.canvas,this.ctx);for(const[t,r]of this.uiLayer.entries())r.debugDraw(this.canvas,this.ctx)}update(){for(var t=0;t<this.layers.length;t++)for(const[r,e]of this.layers[t].entries())e.update(this.dt);for(const[t,r]of this.uiLayer.entries())r.update(this.dt)}updateTransform(){for(var t=0;t<this.layers.length;t++)for(const[r,e]of this.layers[t].entries())e.updateTransform(this);for(const[t,r]of this.uiLayer.entries())r.updateTransform(dt)}delete(t){for(var r=0;r<this.layers.length;r++)this.objects.delete(t)}run(){this.t2=(new Date).getTime(),this.dt=1/(this.t2-this.t1)/1e3,this.update(),this.updateTransform(),this.draw(),this.debug&&this.debugDraw(),this.t1=this.t2}start(){setInterval(this.run,16)}canBeHere(t,r=-1){if(-1==r){r=t.layer;var e=t.colliders;for(const[t,s]of this.layers[r].entries())if(s.colliders.isIntersectingColliders(e))return!1}else for(var s=0;s<this.layers.length;s++)for(const[t,s]of this.layers[r].entries())if(s.colliders.isIntersectingColliders(e))return!1;return!0}}class Drawing{static rotateAndPaintImage(t,r,e,s,i=0){var n=new Vector2D(r.width/2,r.height/2);e+=i,t.translate(s.x,s.y),t.rotate(e),t.drawImage(r,-n.x,-n.y),t.rotate(-e),t.translate(-s.x,-s.y)}static drawArrow(t,r,e,s=10){var i=r.position.sub(e).getModule(),n=new Vector2D(.8*i,s/2).incrementArg(r.rotation).add(r.position),a=new Vector2D(.8*i,-s/2).incrementArg(r.rotation).add(r.position);Drawing.drawLine(t,r.position,e),Drawing.drawLine(t,n,e),Drawing.drawLine(t,a,e)}static drawLine(t,r,e){t.moveTo(r.x,r.y),t.lineTo(e.x,e.y)}static drawCross(t,r,e=10){var s=Vector2D.up().mul(e).add(r),i=Vector2D.down().mul(e).add(r),n=Vector2D.right().mul(e).add(r),a=Vector2D.left().mul(e).add(r);Drawing.drawLine(t,s,i),Drawing.drawLine(t,n,a)}static drawTriangle(t,r,e,s){Drawing.drawLine(t,r,e),Drawing.drawLine(t,s,e),Drawing.drawLine(t,r,s)}}class Key{constructor(t){this.pressed=t}}class InputManager{static init(){document.addEventListener("keydown",InputManager.keyDownHandler,!1),document.addEventListener("keyup",InputManager.keyUpHandler,!1),InputManager.inputs=new Map}static keyDownHandler(t){InputManager.inputs.set(t.key.toString(),new Key(!0))}static keyUpHandler(t){InputManager.inputs.set(t.key,new Key(!1))}static get(t){return InputManager.inputs.has(t)?InputManager.inputs.get(t):new Key(!1)}}class Vector2D{constructor(t,r){this.x=t,this.y=r}add(t){return new Vector2D(this.x+t.x,this.y+t.y)}sub(t){return new Vector2D(this.x-t.x,this.y-t.y)}mul(t){return new Vector2D(this.x*t,this.y*t)}div(t){return new Vector2D(this.x/t,this.y/t)}getModule(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2))}getArg(){return Math.atan2(this.y,this.x)}setArg(t){var r=this.getModule(),e=Math.sin(t)*r,s=Math.cos(t)*r;return this.x=s,this.y=e,this}normalize(){var t=this.getArg(),r=Math.sin(t),e=Math.cos(t);return new Vector2D(e,r)}increment(t){return this.x+=t.x,this.y+=t.y,this}incrementArg(t){var r=this.getArg();return this.setArg(r+t),this}decrement(t){return this.x-=t.x,this.y-=t.y,this}decrementArg(t){var r=this.getArg();return this.setArg(r-t),this}copy(){return new Vector2D(this.x,this.y)}static up(){return new Vector2D(0,1)}static forward(){return new Vector2D(0,1)}static down(){return new Vector2D(0,-1)}static backward(){return new Vector2D(0,-1)}static right(){return new Vector2D(1,0)}static left(){return new Vector2D(-1,0)}static zero(){return new Vector2D(0,0)}}class Transform{constructor(t,r,e=new Vector2D(0,0),s=0){this.position=t,this.rotation=r,this.velocity=e,this.angularVelocity=s}forward(){return Vector2D.forward().setArg(this.rotation)}backward(){return Vector2D.forward().setArg(this.rotation).mul(-1)}up(){return Vector2D.forward().setArg(this.rotation)}down(){return Vector2D.forward().setArg(this.rotation).mul(-1)}left(){return Vector2D.forward().setArg(this.rotation+Math.PI)}right(){return Vector2D.forward().setArg(this.rotation+Math.PI).mul(-1)}}class Triangle{constructor(t,r,e,s){this.center=t,this.p1=r,this.p2=e,this.p3=s,this.baseP1=r.copy(),this.baseP2=e.copy(),this.baseP3=s.copy()}setTransform(t){this.center=t.position.copy(),this.p1=this.baseP1.copy(),this.p2=this.baseP2.copy(),this.p3=this.baseP3.copy(),this.p1.incrementArg(t.rotation).increment(this.center),this.p2.incrementArg(t.rotation).increment(this.center),this.p3.incrementArg(t.rotation).increment(this.center)}static sign(t,r,e){return(t.x-r.x)*(e.y-r.y)-(e.x-r.x)*(t.y-r.y)}isPointInside(t){var r=Triangle.sign(t,this.p1,this.p2)>0,e=Triangle.sign(t,this.p2,this.p3)>0,s=Triangle.sign(t,this.p3,this.p1)>0;return r==e&&e==s}isIntersectingTriangle(t){return!!this.isPointInside(t.p1)||(!!this.isPointInside(t.p2)||(!!this.isPointInside(t.p3)||(!!t.isPointInside(this.p1)||(!!t.isPointInside(this.p2)||(!!t.isPointInside(this.p3)||void 0)))))}draw(t){Drawing.drawTriangle(t,this.p1,this.p2,this.p3)}}class Collider{constructor(t,r=!0){this.transform=t,this.triangles=new Array,this.enabled=r}add(t){this.triangles.push(t)}setTransform(t){this.transform=t;for(const r of this.triangles)r.setTransform(t)}isIntersectingCollider(t){if(t.enabled)for(const r of t.triangles)for(const t of this.triangles)if(r.isIntersectingTriangle(t))return!0;return!1}isPointInside(t){for(const r of this.triangles)if(t1.isPointInside(t))return!0;return!1}enable(){this.enabled=!0}disable(){this.enabled=!1}draw(t){for(const r of this.triangles)r.draw(t)}}class Colliders{constructor(){this.colliders=new Map,this.instantiateId=0}isIntersectingColliders(t){for(const[r,e]of this.colliders.entries())for(const[r,s]of t.colliders.entries())if(e.isIntersectingCollider(s))return!0;return!1}isPointInside(t){for(const[t,r]of this.colliders.entries())if(r.isPointInside(p))return!0;return!1}add(t){this.instantiateId++;var r=this.instantiateId.toString(10);return this.colliders.set(r,t),r}remove(t){this.colliders.delete(t)}enable(t){this.colliders.get(t).enable()}disable(t){this.colliders.get(t).disable()}enableAll(){for(const[t,r]of this.colliders.entries())r.enable()}disableAll(){for(const[t,r]of this.colliders.entries())r.disable()}draw(t){for(const[r,e]of this.colliders.entries())e.draw(t)}update(t){for(const[r,e]of this.colliders.entries())e.setTransform(t)}}class GameObject{constructor(t){this.transform=t,this.colliders=new Colliders}draw(t,r){}debugDraw(t,r){r.beginPath();var e=new Vector2D(30,0).setArg(this.transform.rotation).add(this.transform.position);Drawing.drawArrow(r,this.transform,e,10),Drawing.drawCross(r,this.transform.position),this.colliders.draw(r),r.strokeStyle="#FF0000",r.stroke(),r.closePath()}update(t){}updateTransform(t){var r=t.dt,e=this.transform.angularVelocity*r,s=this.transform.velocity.mul(r);this.transform.rotation+=e,this.colliders.update(this.transform),t.canBeHere(this)||(this.transform.rotation-=e),this.transform.position.x+=s.x,this.colliders.update(this.transform),t.canBeHere(this)||(this.transform.position.x-=s.x),this.transform.position.y+=s.y,this.colliders.update(this.transform),t.canBeHere(this)||(this.transform.position.y-=s.y),this.colliders.update(this.transform)}}class QuadCollider extends Collider{constructor(t,r,e,s,i){super(t),this.add(new Triangle(t.position,r,e,s)),this.add(new Triangle(t.position,s,e,i))}}class TriangleCollider extends Collider{constructor(t,r,e,s){super(t),this.add(new Triangle(t.position,r,e,s))}}class Crate extends GameObject{constructor(t){super(t),this.skin=new Image,this.colliders.add(new QuadCollider(this.transform,new Vector2D(-25,25),new Vector2D(25,25),new Vector2D(-25,-25),new Vector2D(25,-25)))}}class Tank extends GameObject{constructor(t){super(t),this.skin=new Image,this.skin.src="example/tank/Tank.png",this.colliders.add(new QuadCollider(this.transform,new Vector2D(-20,14),new Vector2D(20,14),new Vector2D(-20,-14),new Vector2D(20,-14)))}draw(t,r){Drawing.rotateAndPaintImage(r,this.skin,this.transform.rotation,this.transform.position,-Math.PI/2)}update(t){var r=Vector2D.zero(),e=0;InputManager.get("z").pressed&&r.increment(this.transform.forward().mul(1e4)),InputManager.get("s").pressed&&r.increment(this.transform.velocity=this.transform.backward().mul(1e4)),InputManager.get("d").pressed&&(e+=200),InputManager.get("q").pressed&&(e-=200),this.transform.velocity=r,this.transform.angularVelocity=e}}